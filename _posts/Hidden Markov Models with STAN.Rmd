---
layout: post
title: "Hidden Markov Models"
author: "Rasim M Musal"
date: "2023-10-14"
output:
  html_document:
   theme: darkly
   highlight: espresso
   toc: true
   keep_md: yes
   toc_float: true
   toc_collapsed: true
   toc_depth: 3
   number_sections: true
   usemathjax: true
tags: [rshiny, maps,SMR]
always_allow_html: true
---
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { 
      equationNumbers: {
 
            autoNumber: "all",
            formatNumber: function (n) {return +n}
      } 
  }
});
</script>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning = FALSE, message = FALSE,fig.path = ('./assets/img/2023-10-14-Hidden_Markov_Models_with_STAN'))
```

We had already discussed the [Hidden Markov Models](https://mmusal.github.io/blog/2023/Hidden-Markov-Models/). In this post we will discuss the details of the STAN model as well as the details we skipped in the above post.

Load the libraries, and read in the [SMR data](https://mmusal.github.io/blog/2023/Explaining_rshinyapp/#SMR). 
```{r}
library(ggplot2)
library(tidyr)
library(dplyr)
#E is calculated at every biweek and is the expected number of deaths if
#mortality was uniformly distributed across the population in the state of California
SMR=read.csv(file='SMR.csv',header = TRUE)[,-1]
#First 6 rows
head(SMR)

#Subset the data using dplyr
SMRSubset=SMR %>% filter(County %in% 
c("Alameda","Lassen","Kern","Los Angeles",
"Lassen","San Francisco"))

#Visualize 6 counties of interest.
ggplot(data=SMRSubset,aes(x=Time,y=SMR,color=County))+
geom_line()+  
  theme(legend.position = "right")+
  theme(axis.title.y =element_blank())+
  scale_x_discrete(limits=c(1,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,77))+
  xlab("Biweek t")+
  ggtitle("SMR Values of 6 Counties")+
  theme(plot.title = element_text(hjust = 0.5))


```

In this 
```{STAN}
data { 
  int<lower=1> T;//number of time periods 77
  int K; //This will be fixed to 2
  int<lower=0> N;//number of spatial areas 58 counties in CA
  int<lower=0>  y[T,N]; //observed covid
  matrix [T,N] log_E;
}
```

```{STAN}
transformed data {
  int ITER=END-START+1;
}
```


```{STAN}
parameters {
ordered[K] mu[N]; 
  simplex[K] pi1[1];
  simplex[K] A[K,N];

  real epsilon[T];
}
```

```{STAN}
transformed parameters {
matrix[K,N] lambda [T] ;
real logalpha[T,K,N];
real accumulator[K];
    for(t in 1:T){
  for(k in 1:K){     
    for(n in 1:N){
      lambda[t][k,n]=exp(
        log_E[t,n]+mu[n,k]+epsilon[t]); 
                }
                        }
                }
for(k in 1:K){
  for(n in 1:N){
logalpha[1,k,n] = log(pi1[1,k]) + poisson_lpmf(y[1,n] | lambda[1,k,n]);
}
}

for (t in 2:T) {
for (j in 1:K) {
for (n in 1:N){
accumulator[1] = logalpha[t-1, 1,n] + log(A[1, n,j]) + poisson_lpmf(y[t,n] | lambda[t,j,n]);
accumulator[2] = logalpha[t-1, 2,n] + log(A[2, n,j]) + poisson_lpmf(y[t,n] | lambda[t,j,n]);

logalpha[t, j,n] = log_sum_exp(to_vector(accumulator));}
}
}
} 
```
```{STAN}
model {

for(n in 1:N){  
 target += log_sum_exp(to_vector(logalpha[T,1:K,n]));


  mu[n]~normal(0,3);
}

epsilon~normal(0,3);
}

```

